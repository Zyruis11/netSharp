using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using netSharp.Components;
using netSharp.Events;

namespace netSharp.Objects
{
    public class Session : IDisposable
    {
        private readonly TcpClient _tcpClient;
        private ASCIIEncoding _asciiEncoding;
        private CancellationToken _asyncStreamReaderCancellationToken;
        private Action _messageRecievedCallback;
        private NetworkStream _networkStream;
        private CancellationTokenSource ctSource;

        /// <summary>
        /// </summary>
        /// <param name="ipEndPoint"></param>
        /// <param name="sessionType">0 = Session to Client, 1 = Session to ToServer</param>
        /// <param name="tcpClient"></param>
        public Session(int sessionType, IPEndPoint ipEndPoint, string localGuid, TcpClient tcpClient = null)
        {
            switch (sessionType)
            {
                case 0: // Session to Client, generated by Server.
                {
                    if (tcpClient == null)
                    {
                        throw new Exception("Invalid sessionType");
                    }
                    _tcpClient = tcpClient;
                    RemoteEndpointIpAddressPort = _tcpClient.Client.RemoteEndPoint.ToString();
                    UseHeartbeat = false;
                    break;
                }
                case 1: // Session to Server, generated by Client.
                {
                    if (tcpClient != null)
                    {
                        throw new Exception("Invalid sessionType");
                    }
                    _tcpClient = new TcpClient();
                    RemoteEndpointIp = ipEndPoint;
                    UseHeartbeat = false;
                    break;
                }
                default:
                {
                    Dispose();
                    throw new Exception("Invalid/Unspecified sessionType.");
                }
            }
            LocalEndpointGuid = localGuid;
            RemoteEndpointGuid = "notset";
            if (UseHeartbeat)
            {
                TimeSinceLastHeartbeatRecieve = 0;
                MaxTimeSinceLastHeartbeatReceive = 30;
                TimeUntilNextHeartbeatSend = 0;
            }
            IdleTime = 0;
            MaxIdleTime = 900;
            Connect();
        }

        public bool IsDisposed { get; set; }
        public string RemoteEndpointGuid { get; set; }
        public string LocalEndpointGuid { get; set; }
        public IPEndPoint RemoteEndpointIp { get; set; }
        public string RemoteEndpointIpAddressPort { get; set; }
        public int TimeSinceLastHeartbeatRecieve { get; set; }
        public int MaxTimeSinceLastHeartbeatReceive { get; set; }
        public int TimeUntilNextHeartbeatSend { get; set; }
        public bool UseHeartbeat { get; set; }
        public int IdleTime { get; set; }
        public int MaxIdleTime { get; set; }
        public byte Cost { get; set; }
        public bool SentGuid { get; set; }

        public void Dispose()
        {
            ctSource.Cancel();

            IsDisposed = true;
        }

        public event EventHandler<NetSharpEventArgs> SessionDataRecieved;
        // Event Handler-Trigger Binding
        protected virtual void EventInvocationWrapper(NetSharpEventArgs netSharpEventArgs,
            EventHandler<NetSharpEventArgs> eventHandler)
        {
            if (eventHandler != null)
            {
                eventHandler(this, netSharpEventArgs);
            }
        }

        public void SessionDataRecievedTrigger(DataStream DataStream, Session session)
        {
            EventInvocationWrapper(new NetSharpEventArgs(DataStream, session), SessionDataRecieved);
        }

        private void Connect()
        {
            if (!_tcpClient.Connected)
            {
                _tcpClient.Connect(RemoteEndpointIp);
                RemoteEndpointIpAddressPort = _tcpClient.Client.RemoteEndPoint.ToString();
            }
            _networkStream = _tcpClient.GetStream();

            ctSource = new CancellationTokenSource();
            _asyncStreamReaderCancellationToken = ctSource.Token;

            StreamReaderAsync();
        }

        public void SendData(DataStream DataStream)
        {
            if (DataStream != null)
            {
                StreamWriterAsync(DataStream);
            }
        }

        /// <summary>
        ///     Non-Blocking asynchronous I/O
        /// </summary>
        private async void StreamReaderAsync()
        {
            while (!IsDisposed)
            {
                var incompleteStream = false;
                var protocolInfoBuffer = new byte[10];
                var initialBytesRead = 0;

                // Asynchronously read the network stream
                try
                {
                    initialBytesRead =
                        await _networkStream.ReadAsync(protocolInfoBuffer, 0, protocolInfoBuffer.Length);
                }
                catch
                {
                    break;
                }

                if (initialBytesRead == 0)
                {
                    continue;
                }

                if (!incompleteStream)
                {
                    // Instantiate a new DataStream object to store this recieved stream
                    var dataStream = DataStreamFactory.InitializeStreamObject(protocolInfoBuffer);

                    var payloadBytesRead = 0;
                    var payloadBytesRemaining = dataStream.PayloadLength;
                    dataStream.PayloadByteArray = new byte[dataStream.PayloadLength];

                    // Continue reading the stream until the entire PayloadLength has been read

                    while (payloadBytesRead < dataStream.PayloadLength)
                    {
                        try
                        {
                            payloadBytesRead +=
                                await
                                    _networkStream.ReadAsync(
                                        dataStream.PayloadByteArray, 0,
                                        payloadBytesRemaining, _asyncStreamReaderCancellationToken);
                        }
                        catch
                        {
                            break;
                        }

                        if (payloadBytesRead == 0)
                        {
                            return;
                        }

                        payloadBytesRemaining -= payloadBytesRead;
                    }
                }
            }

            // If cancellation has been requested that means that this object has been disposed
            // cleanup the network resources.
            if (_asyncStreamReaderCancellationToken.IsCancellationRequested)
            {
                _networkStream.Close();
                _tcpClient.Close();
            }
        }

        private async void StreamWriterAsync(DataStream DataStream)
        {
            try
            {
                var serializedDataStream = DataStreamFactory.GetStreamByteArray(DataStream);
                await _networkStream.WriteAsync(serializedDataStream, 0, serializedDataStream.Length);
            }
            catch
            {
                
            }
        }
    }
}