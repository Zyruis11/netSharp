using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using netSharp.TCP.Classes;

namespace netSharp.TCP
{
    public class Session : IDisposable
    {
        private readonly TcpClient _tcpClient;
        private ASCIIEncoding _asciiEncoding;
        private NetworkStream _networkStream;
        private Task _streamReaderThread;

        /// <summary>
        /// </summary>
        /// <param name="ipEndPoint"></param>
        /// <param name="sessionType">0 = Session to Client, 1 = Session to ToServer</param>
        /// <param name="tcpClient"></param>
        public Session(int sessionType, IPEndPoint ipEndPoint, Guid localEndpointGuid, TcpClient tcpClient = null)
        {
            switch (sessionType)
            {
                case 0: // Session to Client, generated by Server.
                {
                    if (tcpClient == null)
                    {
                        throw new Exception("Invalid sessionType");
                    }
                    _tcpClient = tcpClient;
                    RemoteEndpointIpAddressPort = _tcpClient.Client.RemoteEndPoint.ToString();
                    break;
                }
                case 1: // Session to Server, generated by Client.
                {
                    if (tcpClient != null)
                    {
                        throw new Exception("Invalid sessionType");
                    }
                    _tcpClient = new TcpClient();
                    RemoteEndpointIp = ipEndPoint;
                    break;
                }
                default:
                {
                    Dispose();
                    throw new Exception("Invalid/Unspecified sessionType.");
                }
            }

            LocalEndpointGuid = localEndpointGuid;
            Connect();
        }

        public bool IsDisposed { get; set; }
        public int LastTwoWay { get; set; }
        public Guid RemoteEndpointGuid { get; set; }
        public Guid LocalEndpointGuid { get; set; }
        public IPEndPoint RemoteEndpointIp { get; set; }
        public string RemoteEndpointIpAddressPort { get; set; }
        public int HelloInterval { get; set; }

        public void Dispose()
        {
            Disconnect();
            IsDisposed = true;
        }

        public string GetFriendlyEndpointGuid()
        {
            return Convert.ToString(RemoteEndpointGuid).Remove(5);
        }

        private void Connect()
        {
            if (!_tcpClient.Connected)
            {
                _tcpClient.Connect(RemoteEndpointIp);
                RemoteEndpointIpAddressPort = _tcpClient.Client.RemoteEndPoint.ToString();
            }
            _networkStream = _tcpClient.GetStream();
            StartStreamReaderTask();
        }

        public void Disconnect()
        {
            if (_tcpClient.Connected)
            {
                _networkStream.Close();
                _tcpClient.Close();
            }
        }

        public void StartStreamReaderTask()
        {
            _streamReaderThread = new Task(StreamReader);
            _streamReaderThread.Start();
        }

        /// <summary>
        ///     Blocks on the NetworkStream of the TcpClient, it recieves data sent across
        ///     the stream and sends it to a parsing function for further processing.
        /// </summary>
        private void StreamReader()
        {
            while (!IsDisposed)
            {
                _networkStream.Flush();
                ReadStream _readStream = new ReadStream();

                var bytesRead = 0;
                
                var guidBytes = new byte[16];
                bytesRead = _networkStream.Read(guidBytes, 0, guidBytes.Length);

                if (RemoteEndpointGuid == Guid.Empty)
                {
                    RemoteEndpointGuid = new Guid(guidBytes);
                }

                var payloadTypeBytes = new byte[4];
                bytesRead += _networkStream.Read(payloadTypeBytes, 0, payloadTypeBytes.Length);
                _readStream.payloadType = BitConverter.ToInt32(payloadTypeBytes, 0);

                var payloadLengthBytes = new byte[4];
                bytesRead += _networkStream.Read(payloadLengthBytes, 0, payloadLengthBytes.Length);
                _readStream.payloadLength = BitConverter.ToInt32(payloadLengthBytes, 0);

                var payloadBuffer = new byte[_readStream.payloadLength];
                bytesRead += _networkStream.Read(payloadBuffer, 0, payloadBuffer.Length);
                _readStream.payload = payloadBuffer;

                if (bytesRead == 0)
                {
                    break;
                }

                RequestHandler(_readStream);
            }
        }

        private void StreamWriter(byte[] byteArray)
        {
            _networkStream.Write(byteArray, 0, byteArray.Length);
        }

        public byte[] BuildPacket(Guid @guid, int @payloadType, byte[] @payload)
        {
            // Create a byte array list to hold the byte arrays
            List<byte[]> byteArrays = new List<byte[]>();
            int payloadLength = @payload.Length;

            // Use various converters to get the byte arrays for the objects passed into the function.
            byte[] guidByteArray = @guid.ToByteArray();
            byte[] payloadTypeByteArray = BitConverter.GetBytes(payloadType);
            byte[] payloadLengthByteArray = BitConverter.GetBytes(payloadLength);

            // Add the byte arrays to a list
            byteArrays.Add(guidByteArray);
            byteArrays.Add(payloadTypeByteArray);
            byteArrays.Add(payloadLengthByteArray);
            byteArrays.Add(@payload);

            // Return the return value of the byte array list combinator
            return ByteArrayListCombinator(byteArrays);
        }

        private byte[] ByteArrayListCombinator(List<byte[]> @byteArrays)
        {
            byte[] returnArray = new byte[byteArrays.Sum(a => a.Length)];
            int offset = 0;
            foreach (byte[] array in byteArrays)
            {
                Buffer.BlockCopy(array, 0, returnArray, offset, array.Length);
                offset += array.Length;
            }
            return returnArray;
        }


        public void RequestHandler(ReadStream readStream)
        {
           
        }

        public void Test()
        {
            byte[] payload = new byte[1653];
            StreamWriter(BuildPacket(LocalEndpointGuid, 1, payload));
        }
    }
}