using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using netSharp.Core.Data;
using netSharp.Server.Events;

namespace netSharp.Server.Connectivity
{
    public class ServerSession : IDisposable
    {
        private readonly NetworkStream _networkStream;
        private readonly TcpClient _tcpClient;
        private readonly CancellationTokenSource ctSource;
        private CancellationToken _asyncCancellationToken;

        /// <summary>
        /// </summary>
        /// <param name="ipEndPoint"></param>
        /// <param name="sessionType">0 = Session to Client, 1 = Session to ToServer</param>
        /// <param name="tcpClient"></param>
        public ServerSession(int sessionType, IPEndPoint ipEndPoint, string localGuid, TcpClient tcpClient = null)
        {
            switch (sessionType)
            {
                case 0: // Session to Client, generated by Server.
                {
                    if (tcpClient == null)
                    {
                        throw new Exception("Invalid sessionType");
                    }
                    _tcpClient = tcpClient;
                    RemoteEndpointIpAddressPort = _tcpClient.Client.RemoteEndPoint.ToString();
                    break;
                }
                case 1: // Session to Server, generated by Client.
                {
                    if (tcpClient != null)
                    {
                        throw new Exception("Invalid sessionType");
                    }
                    _tcpClient = new TcpClient();
                    RemoteEndpointIp = ipEndPoint;
                    break;
                }
                default:
                {
                    Dispose();
                    throw new Exception("Invalid/Unspecified sessionType.");
                }
            }
            LocalEndpointGuid = localGuid;
            RemoteEndpointGuid = "notset";
            IdleTime = 0;
            MaxIdleTime = 900;

            if (!_tcpClient.Connected)
            {
                _tcpClient.Connect(RemoteEndpointIp);
                RemoteEndpointIpAddressPort = _tcpClient.Client.RemoteEndPoint.ToString();
            }
            _networkStream = _tcpClient.GetStream();

            ctSource = new CancellationTokenSource();
            _asyncCancellationToken = ctSource.Token;
            StreamReaderAsync();
        }

        public bool IsDisposed { get; set; }
        public string RemoteEndpointGuid { get; set; }
        public string LocalEndpointGuid { get; set; }
        public IPEndPoint RemoteEndpointIp { get; set; }
        public string RemoteEndpointIpAddressPort { get; set; }
        public int IdleTime { get; set; }
        public int MaxIdleTime { get; set; }
        public byte Cost { get; set; }
        public bool SentGuid { get; set; }

        public void Dispose()
        {
            ctSource.Cancel();

            IsDisposed = true;
        }

        public event EventHandler<ServerEvents> SessionDataRecieved;
        // Event Handler-Trigger Binding
        protected virtual void EventInvocationWrapper(ServerEvents serverEvents,
            EventHandler<ServerEvents> eventHandler)
        {
            if (eventHandler != null)
            {
                eventHandler(this, serverEvents);
            }
        }

        public void SessionDataRecievedTrigger(DataStream dataStream)
        {
            EventInvocationWrapper(new ServerEvents(dataStream, this), SessionDataRecieved);
        }

        /// <summary>
        ///     Non-Blocking asynchronous I/O
        /// </summary>
        private async void StreamReaderAsync()
        {
            while (!IsDisposed)
            {
                var protocolInfoBuffer = new byte[10];
                var initialBytesRead = 0;

                // Asynchronously read the network stream
                try
                {
                    initialBytesRead =
                        await
                            _networkStream.ReadAsync(protocolInfoBuffer, 0, protocolInfoBuffer.Length,
                                _asyncCancellationToken);
                }
                catch
                {
                    break;
                }

                if (_asyncCancellationToken.IsCancellationRequested)
                {
                    break;
                }

                if (initialBytesRead == 0)
                {
                    continue;
                }

                // Instantiate a new dataStream object to store this recieved stream
                var dataStream = DataStreamFactory.InitializeStreamObject(protocolInfoBuffer);

                var payloadBytesRead = 0;
                var payloadBytesRemaining = dataStream.PayloadLength;
                dataStream.PayloadByteArray = new byte[dataStream.PayloadLength];

                // Continue reading the stream until the entire PayloadLength has been read

                while (payloadBytesRead < dataStream.PayloadLength)
                {
                    try
                    {
                        payloadBytesRead +=
                            await
                                _networkStream.ReadAsync(
                                    dataStream.PayloadByteArray, 0,
                                    payloadBytesRemaining, _asyncCancellationToken);
                    }
                    catch
                    {
                        break;
                    }

                    if (payloadBytesRead == 0)
                    {
                        return;
                    }

                    payloadBytesRemaining -= payloadBytesRead;
                }
            }

            // If cancellation has been requested that means that this object has been disposed
            // cleanup the network resources.
            if (_asyncCancellationToken.IsCancellationRequested)
            {
                _networkStream.Close();
                _tcpClient.Close();
            }
        }

        public async void StreamWriterAsync(DataStream dataStream)
        {
            try
            {
                var serializedDataStream = DataStreamFactory.GetStreamByteArray(dataStream);
                await
                    _networkStream.WriteAsync(serializedDataStream, 0, serializedDataStream.Length,
                        _asyncCancellationToken);
            }
            catch
            {
                // TODO
            }
        }
    }
}